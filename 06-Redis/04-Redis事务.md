## 事务

### Redis事务的本质

一组命令的集合，一个事务中的所有命令都会被序列化，在事务的执行中，会按照顺序执行。

一次性、顺序性、排他性（事务执行的过程中不会被其他事务影响），来执行一系列的命令。

Redis 中有事务，Redis 的单条命令是保证原子性的，但是事务不保证原子性；

Redis 事务中没有隔离级别的概念；

所有的命令在事务中，并没有直接被执行！只有发起执行的命令的时候才会执行 Exec。

<br>

### Redis事务：

* 开启事务（multi）

* 命令入队（...）

* 执行事务（exec）

  放弃事务（discard）

~~~bash
##########################################################
127.0.0.1:6379> multi     # 开启事务
OK
127.0.0.1:6379> set k1 v1 # 命令入队
QUEUED
127.0.0.1:6379> set k2 v2 # 命令入队
QUEUED
127.0.0.1:6379> get k2    # 命令入队
QUEUED
127.0.0.1:6379> set k3 v3 # 命令入队
QUEUED
127.0.0.1:6379> exec      # 执行事务
1) OK
2) OK
3) "v2"
4) OK
##########################################################
127.0.0.1:6379> multi     # 开启事务
OK
127.0.0.1:6379> set k1 v1 # 命令入队
QUEUED
127.0.0.1:6379> set k2 v2 # 命令入队
QUEUED
127.0.0.1:6379> get k2    # 命令入队
QUEUED
127.0.0.1:6379> set k3 v3 # 命令入队
QUEUED
127.0.0.1:6379> discard   # 放弃事务
OK
127.0.0.1:6379> get k3    # 命令入队
(nil)
##########################################################
~~~

<br>

### 编译时异常

代码有问题！命令有错！事务中所有的命令都不会被执行

~~~bash
##########################################################
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set k1 v1
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> setget k3 v3   # 命令出错
(error) ERR unknown command 'setget'
127.0.0.1:6379> set k4 v4
QUEUED
127.0.0.1:6379> exec     # 执行事务报错
(error) EXECABORT Transaction discarded because of previous errors.
127.0.0.1:6379> get k2   # 所有的命令都不会被执行
(nil)
##########################################################
~~~

<br>

### 运行时异常

运行时异常（1/0），如果事务队列中存在语法性错误，入队的时候不会报错，但是执行事务的时候会抛出异常，同时不会影响其他命令的正常执行。

~~~bash
##########################################################
127.0.0.1:6379> set k1 "v1"
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> incr k1
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> set k3 v3
QUEUED
127.0.0.1:6379> get k3
QUEUED
127.0.0.1:6379> exec
1) (error) ERR value is not an integer or out of range
2) OK
3) OK
4) "v3"
127.0.0.1:6379> get k1
"v1"
##########################################################
~~~

<br>

### 监控watch（面试常问）

悲观锁：

* 认为任何时候都会出现问题，无论做什么都会加锁

乐观锁：

* 认为任何时候都不会出现问题，无论做什么都不加锁；更新数据的时候去判断依稀，在此期间是否有人修改过这个数据
* 获取 version
* 更新的时候比较 version

<br>

### Redis监视测试

正常执行成功

~~~bash
##########################################################
127.0.0.1:6379> set money 100
OK
127.0.0.1:6379> set out 0
OK
127.0.0.1:6379> watch money   # 监视money
OK
127.0.0.1:6379> multi    #事务结束，数据期间没有发生变化，这个时候就正常执行成功
OK
127.0.0.1:6379> decrby money 20
QUEUED
127.0.0.1:6379> incrby out 20
QUEUED
127.0.0.1:6379> exec
1) (integer) 80
2) (integer) 20
##########################################################
~~~

<br>

执行失败

~~~bash
##########################################################
# 客户端1
##########################################################
127.0.0.1:6379> watch money  #监视money
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> decrby money 10
QUEUED
127.0.0.1:6379> incrby out 10
QUEUED
127.0.0.1:6379> exec    #修改失败
(nil)
##########################################################
# 客户端2
##########################################################
127.0.0.1:6379> get money
"80"
127.0.0.1:6379> set money 200 #在客户端1未执行事务之前进行数据修改
OK
##########################################################
# 客户端1
##########################################################
127.0.0.1:6379> unwatch    #事务失败之后，对其进行解锁
OK
127.0.0.1:6379> watch money #给money加锁，继续监视，之后执行自己的操作
OK
~~~

执行的时候会去比较监视的 money 的值，如果没有改变则会执行成功，如果改变了，则执行失败。如果修改失败，获取最新数据即可，再继续执行事务。









